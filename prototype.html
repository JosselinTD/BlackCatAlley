<!DOCTYPE html>
<html lang="en">
<head>
    <title>Black Cat Alley - Prototype</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: monospace; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; }
        a { color: #fff; }
        #console-container { position: fixed; bottom: 0; left: 0; right: 0; height: 150px; background-color: rgba(0,0,0,0.7); color: #0f0; font-family: monospace; overflow-y: scroll; padding: 5px; z-index: 9999; border-top: 1px solid #333; }
        #joystick-move-base { position: absolute; bottom: 20px; left: 20px; width: 100px; height: 100px; background: rgba(255,255,255,0.2); border-radius: 50%; display: none; }
        #joystick-move-handle { position: absolute; top: 25px; left: 25px; width: 50px; height: 50px; background: rgba(255,255,255,0.4); border-radius: 50%; }
        #joystick-look-base { position: absolute; bottom: 20px; right: 20px; width: 100px; height: 100px; background: rgba(255,255,255,0.2); border-radius: 50%; display: none; }
        #joystick-look-handle { position: absolute; top: 25px; left: 25px; width: 50px; height: 50px; background: rgba(255,255,255,0.4); border-radius: 50%; }
    </style>
</head>
<body>
    <div id="info">
        Black Cat Alley - Prototype<br/>
        (Utilisez le joystick droit pour regarder)
    </div>
    <button id="toggle-console" style="position: fixed; top: 10px; right: 10px; z-index: 10001; background: #333; color: #fff; border: 1px solid #fff; padding: 5px;">Toggle Console</button>
    <button id="flashlight-button" style="position: fixed; bottom: 130px; left: 50%; transform: translateX(-50%); z-index: 10001; background: #555; color: #fff; border: 1px solid #fff; padding: 10px 15px; border-radius: 5px; font-family: monospace;">Flashlight</button>
    <div id="console-container"></div>
    <div id="joystick-move-base"><div id="joystick-move-handle"></div></div>
    <div id="joystick-look-base"><div id="joystick-look-handle"></div></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // From three.js/examples/jsm/webxr/VRButton.js
        const VRButton = {
            createButton: function (renderer) {
                const button = document.createElement('button');
                function showEnterVR() {
                    let currentSession = null;
                    async function onSessionStarted(session) {
                        session.addEventListener('end', onSessionEnded);
                        await renderer.xr.setSession(session);
                        button.textContent = 'EXIT VR';
                        currentSession = session;
                    }
                    function onSessionEnded() {
                        currentSession.removeEventListener('end', onSessionEnded);
                        button.textContent = 'ENTER VR';
                        currentSession = null;
                    }
                    button.style.display = '';
                    button.style.cursor = 'pointer';
                    button.style.left = 'calc(50% - 50px)';
                    button.style.width = '100px';
                    button.textContent = 'ENTER VR';
                    button.onclick = function () {
                        if (currentSession === null) {
                            navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor'] }).then(onSessionStarted);
                        } else {
                            currentSession.end();
                        }
                    };
                }
                function showWebXRNotFound() {
                    button.style.display = '';
                    button.style.cursor = 'auto';
                    button.style.left = 'calc(50% - 75px)';
                    button.style.width = '150px';
                    button.textContent = 'VR NOT SUPPORTED';
                    button.onclick = null;
                }
                button.id = 'VRButton';
                button.style.display = 'none';
                button.style.position = 'absolute';
                button.style.bottom = '20px';
                button.style.padding = '12px 6px';
                button.style.border = '1px solid #fff';
                button.style.borderRadius = '4px';
                button.style.background = 'rgba(0,0,0,0.1)';
                button.style.color = '#fff';
                button.style.font = 'normal 13px sans-serif';
                button.style.textAlign = 'center';
                button.style.opacity = '0.5';
                button.style.outline = 'none';
                button.style.zIndex = '999';
                if ('xr' in navigator) {
                    navigator.xr.isSessionSupported('immersive-vr').then(supported => supported ? showEnterVR() : showWebXRNotFound());
                } else {
                    const message = document.createElement('a');
                    if (window.isSecureContext === false) {
                        message.href = document.location.href.replace(/^http:/, 'https:');
                        message.innerHTML = 'WEBXR NEEDS HTTPS';
                    } else {
                        message.href = 'https://immersiveweb.dev/';
                        message.innerHTML = 'WEBXR NOT AVAILABLE';
                    }
                    return message; // Return message element if no XR
                }
                return button;
            }
        };
    </script>
    <script>
        // --- On-screen console ---
        function setupOnScreenConsole() {
            const container = document.getElementById('console-container');
            if (!container) return;
            const log = (message, color) => {
                const p = document.createElement('p');
                p.style.margin = '2px';
                p.style.wordBreak = 'break-all';
                p.style.color = color || '#0f0';
                try { p.textContent = '> ' + JSON.stringify(message); } catch (e) { p.textContent = '> [Unserializable object]'; }
                container.appendChild(p);
                container.scrollTop = container.scrollHeight;
            };
            const original = { log: console.log, warn: console.warn, error: console.error };
            window.onerror = (msg, url, line) => { log(`ERROR: ${msg} at line ${line}`, '#f00'); };
            console.log = (...args) => { log(args.length === 1 ? args[0] : args); original.log.apply(console, args); };
            console.warn = (...args) => { log(args.length === 1 ? args[0] : args, '#ff0'); original.warn.apply(console, args); };
            console.error = (...args) => { log(args.length === 1 ? args[0] : args, '#f00'); original.error.apply(console, args); };
            console.log('On-screen console initialized.');
        }
        setupOnScreenConsole();

        document.getElementById('toggle-console').addEventListener('click', () => {
            const consoleContainer = document.getElementById('console-container');
            consoleContainer.style.display = consoleContainer.style.display === 'none' ? 'block' : 'none';
        });

        // --- Game Constants ---
        const moveSpeed = 5;
        const lookSpeed = 2;
        const mazeWidth = 15, mazeHeight = 15, wallSize = 8; // Wallsize is now 8
        const minBuildingHeight = 3, maxBuildingHeight = 12;
        const catSpawnInterval = 5; // seconds
        const catSpeed = 2;

        // --- Game State ---
        let camera, scene, renderer, maze, clock, eyeTexture, spotLight;
        const controls = { forward: false, backward: false, left: false, right: false };
        const lookInput = { x: 0, y: 0 };
        const cats = [];
        let spawnTimer = 0;

        function createEyeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.beginPath();
            context.arc(32, 32, 30, 0, 2 * Math.PI);
            context.fillStyle = '#FFFFFF';
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            try {
                clock = new THREE.Clock();
                eyeTexture = createEyeTexture();
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.xr.enabled = true;
                document.body.appendChild(renderer.domElement);

                document.body.appendChild(VRButton.createButton(renderer));

                maze = generateMaze(mazeWidth, mazeHeight);
                const mazeMesh = createMazeMesh(maze);
                scene.add(mazeMesh);

                // Start the player in the center of the first empty cell
                const startX = 1.5 * wallSize;
                const startZ = 1.5 * wallSize;
                camera.position.set(startX, 1.6, startZ);

                addMovementListeners();
                setupMoveJoystick();
                setupLookJoystick();
                window.addEventListener('resize', onWindowResize, false);

                // --- Ground Plane ---
                const groundGeometry = new THREE.PlaneGeometry(mazeWidth * wallSize, mazeHeight * wallSize);
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a }); // Even darker grey for ground
                const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                groundMesh.rotation.x = -Math.PI / 2; // Lay it flat
                groundMesh.position.set((mazeWidth * wallSize) / 2, 0, (mazeHeight * wallSize) / 2);
                scene.add(groundMesh);

                // --- Flashlight Setup ---
                spotLight = new THREE.SpotLight(0xffffff, 100);
                spotLight.angle = Math.PI / 16; // ~11 degrees, narrower beam
                spotLight.penumbra = 0; // Hardest edge
                                spotLight.decay = 0; // No falloff for arcade style
                spotLight.distance = 40;

                // Attach light to camera
                camera.add(spotLight);
                camera.add(spotLight.target);

                // Position the light source below the camera (chest level)
                spotLight.position.set(0, -0.6, 0);
                
                // Position the target in front of the light source
                spotLight.target.position.set(0, -0.6, -1);

                spotLight.visible = false;
                if (camera.parent === null) scene.add(camera);

                let flashlightOn = false;
                document.getElementById('flashlight-button').addEventListener('click', () => {
                    flashlightOn = !flashlightOn;
                    spotLight.visible = flashlightOn;
                });
            } catch (e) {
                console.error(e);
            }
        }

        function generateMaze(width, height) {
            const maze = Array(height).fill(0).map(() => Array(width).fill(1));
            const stack = [[1, 1]];
            maze[1][1] = 0;
            while (stack.length > 0) {
                const [cx, cy] = stack[stack.length - 1];
                const neighbors = [];
                if (cx > 1 && maze[cy][cx - 2] === 1) neighbors.push([cx - 2, cy, cx - 1, cy]);
                if (cx < width - 2 && maze[cy][cx + 2] === 1) neighbors.push([cx + 2, cy, cx + 1, cy]);
                if (cy > 1 && maze[cy - 2][cx] === 1) neighbors.push([cx, cy - 2, cx, cy - 1]);
                if (cy < height - 2 && maze[cy + 2][cx] === 1) neighbors.push([cx, cy + 2, cx, cy + 1]);
                if (neighbors.length > 0) {
                    const [nx, ny, wx, wy] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[ny][nx] = 0;
                    maze[wy][wx] = 0;
                    stack.push([nx, ny]);
                } else {
                    stack.pop();
                }
            }
            return maze;
        }

        function createMazeMesh(maze) {
            const buildings = new THREE.Group();
            const width = maze[0].length;
            const height = maze.length;

                        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 }); // Dark grey so it can be lit, standard for better quality
            const outlineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff }); // White outlines

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (maze[y][x] === 1) { // It's a wall block
                        const wallX = x * wallSize;
                        const wallZ = y * wallSize;
                        const buildingHeight = minBuildingHeight + Math.random() * (maxBuildingHeight - minBuildingHeight);

                        // Create the solid black building
                        const wallGeometry = new THREE.BoxGeometry(wallSize, buildingHeight, wallSize);
                        const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallMesh.position.set(wallSize / 2, buildingHeight / 2, wallSize / 2);

                        // Create the white outline for the top
                        const topOutlineGeometry = new THREE.BufferGeometry();
                        const topVertices = new Float32Array([
                            0, buildingHeight, 0,
                            wallSize, buildingHeight, 0,

                            wallSize, buildingHeight, 0,
                            wallSize, buildingHeight, wallSize,

                            wallSize, buildingHeight, wallSize,
                            0, buildingHeight, wallSize,

                            0, buildingHeight, wallSize,
                            0, buildingHeight, 0
                        ]);
                        topOutlineGeometry.setAttribute('position', new THREE.BufferAttribute(topVertices, 3));
                        const topOutline = new THREE.LineSegments(topOutlineGeometry, outlineMaterial);

                        // Group building and outline together
                        const buildingGroup = new THREE.Group();
                        buildingGroup.add(wallMesh);
                        buildingGroup.add(topOutline);

                        // Create the BLACK outline for the bottom to separate from the ground
                        const bottomOutlineGeometry = new THREE.BufferGeometry();
                        const y_offset = 0.01; // Tiny offset to prevent z-fighting with the ground
                        const bottomVertices = new Float32Array([
                            0, y_offset, 0,
                            wallSize, y_offset, 0,

                            wallSize, y_offset, 0,
                            wallSize, y_offset, wallSize,

                            wallSize, y_offset, wallSize,
                            0, y_offset, wallSize,

                            0, y_offset, wallSize,
                            0, y_offset, 0
                        ]);
                        bottomOutlineGeometry.setAttribute('position', new THREE.BufferAttribute(bottomVertices, 3));
                        const bottomOutlineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                        const bottomOutline = new THREE.LineSegments(bottomOutlineGeometry, bottomOutlineMaterial);
                        buildingGroup.add(bottomOutline);

                        // Add white details (windows) with overlap prevention
                        const detailMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                        const windowProbability = 0.8;
                        const minWindowMargin = 0.4;

                        if (Math.random() < windowProbability) {
                            const windowRectsByFace = { 0: [], 1: [], 2: [], 3: [] };
                            const numWindows = Math.floor(Math.random() * 8) + 4;
                            let attempts = 0;

                            for (let i = 0; i < numWindows && attempts < 100; attempts++) {
                                const windowWidth = 0.5 + Math.random() * 1.5;
                                const windowHeight = 0.5 + Math.random() * 2.5;
                                
                                const faceIndex = Math.floor(Math.random() * 4);
                                
                                const rect = {
                                    x: Math.random() * (wallSize - windowWidth),
                                    y: Math.random() * (buildingHeight - windowHeight),
                                    width: windowWidth,
                                    height: windowHeight
                                };

                                let hasOverlap = false;
                                for (const existingRect of windowRectsByFace[faceIndex]) {
                                    if (!(rect.x > existingRect.x + existingRect.width + minWindowMargin ||
                                          rect.x + rect.width + minWindowMargin < existingRect.x ||
                                          rect.y > existingRect.y + existingRect.height + minWindowMargin ||
                                          rect.y + rect.height + minWindowMargin < existingRect.y)) {
                                        hasOverlap = true;
                                        break;
                                    }
                                }

                                if (!hasOverlap) {
                                    windowRectsByFace[faceIndex].push(rect);

                                    const windowGeometry = new THREE.PlaneGeometry(rect.width, rect.height);
                                    const windowMesh = new THREE.Mesh(windowGeometry, detailMaterial);
                                    
                                    const epsilon = 0.01;

                                    const posX = rect.x + rect.width / 2;
                                    const posY = rect.y + rect.height / 2;

                                    switch (faceIndex) {
                                        case 0: // Front face (+Z)
                                            windowMesh.position.set(posX, posY, wallSize + epsilon);
                                            break;
                                        case 1: // Back face (-Z)
                                            windowMesh.position.set(posX, posY, -epsilon);
                                            windowMesh.rotation.y = Math.PI;
                                            break;
                                        case 2: // Right face (+X)
                                            windowMesh.position.set(wallSize + epsilon, posY, posX);
                                            windowMesh.rotation.y = Math.PI / 2;
                                            break;
                                        case 3: // Left face (-X)
                                            windowMesh.position.set(-epsilon, posY, posX);
                                            windowMesh.rotation.y = -Math.PI / 2;
                                            break;
                                    }
                                    buildingGroup.add(windowMesh);
                                    i++;
                                }
                            }
                        }

                        buildingGroup.position.set(wallX, 0, wallZ);
                        buildings.add(buildingGroup);
                    }
                }
            }
            return buildings;
        }

        function setupMoveJoystick() {
            console.log("Setting up move joystick...");

            const base = document.getElementById('joystick-move-base');
            const handle = document.getElementById('joystick-move-handle');
            base.style.display = 'block';

            setTimeout(() => {
                const handleRadius = handle.offsetWidth / 2;
                const baseRadius = base.offsetWidth / 2;
                if (baseRadius === 0) {
                    console.error("Joystick size is 0. It might be hidden or not rendered yet.");
                    return;
                }
                
                let touchId = null;
                let center = { x: 0, y: 0 };

                base.addEventListener('touchstart', e => {
                    e.preventDefault();
                    if (touchId === null) {
                        const touch = e.changedTouches[0];
                        touchId = touch.identifier;
                        const baseRect = base.getBoundingClientRect();
                        center = { x: baseRect.left + baseRadius, y: baseRect.top + baseRadius };
                    }
                }, { passive: false });

                document.addEventListener('touchmove', e => {
                    if (touchId === null) return;
                    let touch;
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === touchId) {
                            touch = e.changedTouches[i];
                            break;
                        }
                    }
                    if (!touch) return;

                    const vec = { x: touch.clientX - center.x, y: touch.clientY - center.y };
                    const distance = Math.min(Math.sqrt(vec.x * vec.x + vec.y * vec.y), baseRadius);
                    const angle = Math.atan2(vec.y, vec.x);

                    handle.style.left = `${baseRadius - handleRadius + Math.cos(angle) * distance}px`;
                    handle.style.top = `${baseRadius - handleRadius + Math.sin(angle) * distance}px`;

                    const deadzone = 0.2;
                    const normX = Math.cos(angle) * (distance / baseRadius);
                    const normY = Math.sin(angle) * (distance / baseRadius);

                    controls.forward = normY < -deadzone;
                    controls.backward = normY > deadzone;
                    controls.left = normX < -deadzone;
                    controls.right = normX > deadzone;

                }, { passive: false });

                window.addEventListener('touchend', e => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === touchId) {
                            handle.style.left = `${baseRadius - handleRadius}px`;
                            handle.style.top = `${baseRadius - handleRadius}px`;
                            controls.forward = false;
                            controls.backward = false;
                            controls.left = false;
                            controls.right = false;
                            touchId = null;
                            break;
                        }
                    }
                });
            }, 100);
        }

        function setupLookJoystick() {
            console.log("Setting up look joystick...");

            const base = document.getElementById('joystick-look-base');
            const handle = document.getElementById('joystick-look-handle');
            base.style.display = 'block';

            setTimeout(() => {
                const handleRadius = handle.offsetWidth / 2;
                const baseRadius = base.offsetWidth / 2;
                if (baseRadius === 0) {
                    console.error("Look Joystick size is 0. It might be hidden or not rendered yet.");
                    return;
                }
                
                let touchId = null;
                let center = { x: 0, y: 0 };

                base.addEventListener('touchstart', e => {
                    e.preventDefault();
                    if (touchId === null) {
                        const touch = e.changedTouches[0];
                        touchId = touch.identifier;
                        const baseRect = base.getBoundingClientRect();
                        center = { x: baseRect.left + baseRadius, y: baseRect.top + baseRadius };
                    }
                }, { passive: false });

                document.addEventListener('touchmove', e => {
                    if (touchId === null) return;
                    let touch;
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === touchId) {
                            touch = e.changedTouches[i];
                            break;
                        }
                    }
                    if (!touch) return;

                    const vec = { x: touch.clientX - center.x, y: touch.clientY - center.y };
                    const distance = Math.min(Math.sqrt(vec.x * vec.x + vec.y * vec.y), baseRadius);
                    const angle = Math.atan2(vec.y, vec.x);

                    handle.style.left = `${baseRadius - handleRadius + Math.cos(angle) * distance}px`;
                    handle.style.top = `${baseRadius - handleRadius + Math.sin(angle) * distance}px`;

                    const deadzone = 0.2;
                    const normX = Math.cos(angle) * (distance / baseRadius);
                    const normY = Math.sin(angle) * (distance / baseRadius);

                    if ((distance / baseRadius) < deadzone) {
                        lookInput.x = 0;
                        lookInput.y = 0;
                    } else {
                        lookInput.x = normX;
                        lookInput.y = normY;
                    }

                }, { passive: false });

                window.addEventListener('touchend', e => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === touchId) {
                            handle.style.left = `${baseRadius - handleRadius}px`;
                            handle.style.top = `${baseRadius - handleRadius}px`;
                            lookInput.x = 0;
                            lookInput.y = 0;
                            touchId = null;
                            break;
                        }
                    }
                });
            }, 100);
        }

        function addMovementListeners() {
            window.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'KeyW': case 'KeyZ': controls.forward = true; break;
                    case 'KeyS': controls.backward = true; break;
                    case 'KeyA': case 'KeyQ': controls.left = true; break;
                    case 'KeyD': controls.right = true; break;
                }
            });
            window.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': case 'KeyZ': controls.forward = false; break;
                    case 'KeyS': controls.backward = false; break;
                    case 'KeyA': case 'KeyQ': controls.left = false; break;
                    case 'KeyD': controls.right = false; break;
                }
            });
        }

        function handleMovement(deltaTime) {
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const leftVector = new THREE.Vector3().crossVectors(camera.up, direction);

            if (controls.forward) velocity.add(direction);
            if (controls.backward) velocity.sub(direction);
            if (controls.left) velocity.add(leftVector);
            if (controls.right) velocity.sub(leftVector);

            velocity.normalize().multiplyScalar(moveSpeed * deltaTime);

            // Check each axis separately
            const newPosX = camera.position.clone().add(new THREE.Vector3(velocity.x, 0, 0));
            if (isPositionValid(newPosX)) {
                camera.position.x = newPosX.x;
            }

            const newPosZ = camera.position.clone().add(new THREE.Vector3(0, 0, velocity.z));
            if (isPositionValid(newPosZ)) {
                camera.position.z = newPosZ.z;
            }
        }

        function isPositionValid(posToValidate) {
            const radius = 0.4; // Collision radius for player and cats
            const pointsToCheck = [
                posToValidate,
                new THREE.Vector3(posToValidate.x + radius, posToValidate.y, posToValidate.z),
                new THREE.Vector3(posToValidate.x - radius, posToValidate.y, posToValidate.z),
                new THREE.Vector3(posToValidate.x, posToValidate.y, posToValidate.z + radius),
                new THREE.Vector3(posToValidate.x, posToValidate.y, posToValidate.z - radius)
            ];

            for (const point of pointsToCheck) {
                const gridX = Math.floor(point.x / wallSize);
                const gridZ = Math.floor(point.z / wallSize);

                if (gridX < 0 || gridX >= mazeWidth || gridZ < 0 || gridZ >= mazeHeight || (maze[gridZ] && maze[gridZ][gridX] === 1)) {
                    // console.error(`Collision! Pos: (${point.x.toFixed(2)}, ${point.z.toFixed(2)}), Grid: (${gridX}, ${gridZ})`);
                    return false; // One of the points is in a wall
                }
            }
            return true;
        }

        function handleRotation(deltaTime) {
            if (lookInput.x === 0 && lookInput.y === 0) return;

            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            euler.setFromQuaternion(camera.quaternion);

            euler.y -= lookInput.x * lookSpeed * deltaTime;
            euler.x -= lookInput.y * lookSpeed * deltaTime;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            
            camera.quaternion.setFromEuler(euler);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function spawnCat() {
            const catGroup = new THREE.Group();
            const eyeSpacing = 0.25;
            
            const eyeMaterial = new THREE.SpriteMaterial({ map: eyeTexture, color: 0xffffff });

            // Create the two round eyes
            const eyeL = new THREE.Sprite(eyeMaterial);
            const eyeR = new THREE.Sprite(eyeMaterial.clone());

            // Set the scale for round eyes
            const eyeScale = 0.25; // Reduced from 0.3
            eyeL.scale.set(eyeScale, eyeScale, 1);
            eyeR.scale.set(eyeScale, eyeScale, 1);

            eyeL.position.x = -eyeSpacing / 2;
            eyeR.position.x = eyeSpacing / 2;
            catGroup.add(eyeL);
            catGroup.add(eyeR);

            // Add a black body for presence and collision
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const bodyGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.8);
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.position.y = -0.25;
            bodyMesh.visible = false; // Make the body invisible but keep it for collisions
            catGroup.add(bodyMesh);

            // Find a valid spawn position
            let spawnPos = null;
            while (spawnPos === null) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 10;
                const pos = new THREE.Vector3(
                    camera.position.x + Math.cos(angle) * distance,
                    1.0, // Eye level height
                    camera.position.z + Math.sin(angle) * distance
                );
                if (isPositionValid(pos)) {
                    spawnPos = pos;
                }
            }

            catGroup.position.copy(spawnPos);
            scene.add(catGroup);
            cats.push({
                mesh: catGroup, 
                radius: 0.5, // Approximate radius for collision
                blinkTimer: Math.random() * 5,
                isBlinking: false,
                speed: catSpeed * (0.8 + Math.random() * 0.7),
                state: 'moving',
                stateTimer: 1 + Math.random() * 2,
                wanderAngle: Math.random() * Math.PI * 2 // Initial wander direction
            });
        }

        function updateCats(deltaTime) {
            const lightPos = new THREE.Vector3();
            const targetPos = new THREE.Vector3();
            const lightDir = new THREE.Vector3();
            const isLightOn = spotLight.visible;

            if (isLightOn) {
                spotLight.getWorldPosition(lightPos);
                spotLight.target.getWorldPosition(targetPos);
                lightDir.subVectors(targetPos, lightPos).normalize();
            }

            for (let i = cats.length - 1; i >= 0; i--) {
                const cat = cats[i];
                let isLit = false;

                if (isLightOn) {
                    const vectorToCat = new THREE.Vector3().subVectors(cat.mesh.position, lightPos);
                    const distanceToCat = vectorToCat.length();
                    if (distanceToCat > 0 && distanceToCat < spotLight.distance) {
                        const angleToCat = lightDir.angleTo(vectorToCat.normalize());
                        if (angleToCat < spotLight.angle) {
                            isLit = true;
                        }
                    }
                }

                if (isLit) {
                    scene.remove(cat.mesh);
                    cats.splice(i, 1);
                } else {
                    // --- State Machine for Pausing/Moving ---
                    cat.stateTimer -= deltaTime;
                    if (cat.stateTimer <= 0) {
                        if (cat.state === 'moving') {
                            cat.state = 'pausing';
                            cat.stateTimer = 0.5 + Math.random() * 1.0; // Pause for 0.5-1.5s
                        } else { // state is 'pausing'
                            cat.state = 'moving';
                            cat.stateTimer = 1.5 + Math.random() * 2.0; // Move for 1.5-3.5s
                        }
                    }

                    // --- Movement Logic (only if in 'moving' state) ---
                    if (cat.state === 'moving') {
                        // --- Calculate Wander + Homing Direction ---
                        const targetDirection = new THREE.Vector3().subVectors(camera.position, cat.mesh.position);
                        targetDirection.y = 0;
                        targetDirection.normalize();

                        // Update and apply wander
                        const wanderStrength = 0.5; // How much the wander angle can change per frame
                        const wanderInfluence = 0.4; // How much the wander direction affects the final direction (0-1)

                        cat.wanderAngle += (Math.random() - 0.5) * wanderStrength;
                        const wanderDirection = new THREE.Vector3(Math.cos(cat.wanderAngle), 0, Math.sin(cat.wanderAngle));

                        // Blend the two directions
                        const finalDirection = new THREE.Vector3().lerpVectors(targetDirection, wanderDirection, wanderInfluence);
                        finalDirection.normalize();

                        let velocity = finalDirection.multiplyScalar(cat.speed * deltaTime);
                        let newPos = cat.mesh.position.clone().add(velocity);

                        cats.forEach(otherCat => {
                            if (cat === otherCat) return;
                            const distance = newPos.distanceTo(otherCat.mesh.position);
                            const minDistance = cat.radius + otherCat.radius;
                            if (distance < minDistance) {
                                const overlap = minDistance - distance;
                                const pushVector = new THREE.Vector3().subVectors(newPos, otherCat.mesh.position).normalize();
                                newPos.add(pushVector.multiplyScalar(overlap));
                            }
                        });

                        const finalPos = cat.mesh.position.clone();
                        const moveX = new THREE.Vector3(newPos.x - finalPos.x, 0, 0);
                        if (isPositionValid(finalPos.clone().add(moveX))) {
                            finalPos.add(moveX);
                        }
                        const moveZ = new THREE.Vector3(0, 0, newPos.z - finalPos.z);
                        if (isPositionValid(finalPos.clone().add(moveZ))) {
                            finalPos.add(moveZ);
                        }
                        cat.mesh.position.copy(finalPos);
                    }

                    // --- Appearance (applies to both moving and paused cats) ---
                    cat.mesh.lookAt(camera.position);

                    cat.blinkTimer += deltaTime;
                    const blinkInterval = 3 + Math.random() * 4;
                    const blinkDuration = 0.15;

                    if (!cat.isBlinking && cat.blinkTimer > blinkInterval) {
                        cat.isBlinking = true;
                        cat.mesh.children[0].visible = false; // eyeL
                        cat.mesh.children[1].visible = false; // eyeR
                        cat.blinkTimer = 0;
                    }

                    if (cat.isBlinking && cat.blinkTimer > blinkDuration) {
                        cat.isBlinking = false;
                        cat.mesh.children[0].visible = true; // eyeL
                        cat.mesh.children[1].visible = true; // eyeR
                        cat.blinkTimer = 0;
                    }
                }
            }
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                const deltaTime = clock.getDelta();
                spawnTimer += deltaTime;

                handleRotation(deltaTime);
                handleMovement(deltaTime);
                updateCats(deltaTime);

                

                if (spawnTimer > catSpawnInterval) {
                    spawnCat();
                    spawnTimer = 0;
                }

                renderer.render(scene, camera);
            });
        }

        init();
        animate();
    </script>
</body>
</html>
